//
// I2C_EEPROM : using I2C1 to access EEPROM
//
// EVB    : Nu-LB-NUC140
// MCU    : NUC140VE3CN (LQFP100)
// EEPROM : 24LC64
//          I2C@400KHz (2.5~5.5V)
//
// EEPROM I2C connections:
// I2C1-SCL/PA11
// I2C1-SDA/PA10

#include <stdio.h>
#include <stdbool.h>
#include "NUC100Series.h"
#include "MCU_init.h"
#include "SYS_init.h"
#include "Seven_Segment.h"
#include "LCD.h"
#include "i2c.h"

// Global variables
volatile uint8_t g_u8DeviceAddr;
volatile uint8_t g_au8TxData[3];
volatile uint8_t g_u8RxData;
volatile uint8_t g_u8DataLen;
volatile uint8_t g_u8EndFlag = 0;
int test_mode=0;
typedef void (*I2C_FUNC)(uint32_t u32Status);
static I2C_FUNC s_I2C1HandlerFn = NULL;

typedef struct pass{
	int index;
	int value[4];
	int xpos;
	int ypos;

}number;
number password;
number guess;
volatile uint8_t KEY_Flag;
volatile uint32_t index_5ms, cnt_5ms, cnt_1s, cnt_100ms,index_key_scan;
volatile uint32_t digit[4];
volatile uint32_t count_Line, count_Char;


void TMR1_IRQHandler(void)
{	
	cnt_5ms++;
	index_5ms = cnt_5ms % 4;
	CloseSevenSegment();
	
	if (cnt_5ms % 20 == 0) 
	{
		cnt_100ms++;
		index_key_scan = cnt_100ms++ % 3;
		if (index_key_scan == 0)
		{
			PA0=1; PA1=1; PA2=1; PA3=1; PA4=1; PA5=0;
		}
		if (index_key_scan == 1)
		{
			PA0=1; PA1=1; PA2=1; PA3=1; PA4=0; PA5=1;
		}
		if (index_key_scan == 2)
		{
			PA0=1; PA1=1; PA2=1; PA3=0; PA4=1; PA5=1;
		}
		NVIC_EnableIRQ(GPAB_IRQn);
	}
	
	if (cnt_5ms % 200 == 0) cnt_1s++;	

  TIMER_ClearIntFlag(TIMER1); // Clear Timer1 time-out interrupt flag
}

void GPAB_IRQHandler(void)
{
		NVIC_DisableIRQ(GPAB_IRQn);
	
if (PA->ISRC & BIT0) {        // check if PA0 interrupt occurred
		PA0=1;
	  PA->ISRC |= BIT0;         // clear PA0 interrupt status
	
if (PA3==0) { KEY_Flag =3; PA3=1;}
if (PA4==0) { KEY_Flag =6; PA4=1;}
if (PA5==0) { KEY_Flag =9; PA5=1;}
return;			
} 
if (PA->ISRC & BIT1) { // check if PA1 interrupt occurred
		PA1=1;
	  PA->ISRC |= BIT1;         // clear PA1 interrupt status  
if (PA3==0) { KEY_Flag =2; PA3=1;}
if (PA4==0) { KEY_Flag =5; PA4=1;}
if (PA5==0) { KEY_Flag =8; PA5=1;} 
return;				
} 
if (PA->ISRC & BIT2) { // check if PB14 interrupt occurred
		PA2=1;
	  PA->ISRC |= BIT2;         // clear PA interrupt status  
if (PA3==0) { KEY_Flag =1; PA3=1;}
if (PA4==0) { KEY_Flag =4; PA4=1;}
if (PA5==0) { KEY_Flag =7; PA5=1;}
return;				
}                     // else it is unexpected interrupts
PA->ISRC = PA->ISRC;	      // clear all GPB pins
}


void Init_Timer1(void)
{
  TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 200);
  TIMER_EnableInt(TIMER1);
  NVIC_EnableIRQ(TMR1_IRQn);
  TIMER_Start(TIMER1);
}

void Init_KEY(void)
{
		GPIO_SetMode(PA, (BIT0 | BIT1 | BIT2 |BIT3 | BIT4 | BIT5), GPIO_MODE_QUASI);
		GPIO_EnableInt(PA, 0, GPIO_INT_LOW);
		GPIO_EnableInt(PA, 1, GPIO_INT_LOW);
		GPIO_EnableInt(PA, 2, GPIO_INT_LOW);		
		NVIC_EnableIRQ(GPAB_IRQn);   
	  NVIC_SetPriority(GPAB_IRQn,3);
		GPIO_SET_DEBOUNCE_TIME(GPIO_DBCLKSRC_LIRC, GPIO_DBCLKSEL_256);
		GPIO_ENABLE_DEBOUNCE(PA, (BIT0 | BIT1 | BIT2));			
}


void I2C1_IRQHandler(void)
{
    uint32_t u32Status;

    u32Status = I2C_GET_STATUS(I2C1);
    if(I2C_GET_TIMEOUT_FLAG(I2C1))
    {
        I2C_ClearTimeoutFlag(I2C1); // Clear I2C1 Timeout Flag
    }
    else
    {
        if(s_I2C1HandlerFn != NULL)
            s_I2C1HandlerFn(u32Status);
    }
}

/*---------------------------------------------------------------------------------------------------------*/
/*  I2C Rx Callback Function                                                                               */
/*---------------------------------------------------------------------------------------------------------*/
void I2C_MasterRx(uint32_t u32Status)
{
    if(u32Status == 0x08)                       // START has been transmitted and prepare SLA+W
    {
        I2C_SET_DATA(I2C1, (g_u8DeviceAddr << 1));    // Write SLA+W to Register I2CDAT
        I2C_SET_CONTROL_REG(I2C1, I2C_I2CON_SI);
    }
    else if(u32Status == 0x18)                  // SLA+W has been transmitted and ACK has been received
    {
        I2C_SET_DATA(I2C1, g_au8TxData[g_u8DataLen++]);
        I2C_SET_CONTROL_REG(I2C1, I2C_I2CON_SI);
    }
    else if(u32Status == 0x20)                  // SLA+W has been transmitted and NACK has been received
    {
        I2C_STOP(I2C1);
        I2C_START(I2C1);
    }
    else if(u32Status == 0x28)                  // DATA has been transmitted and ACK has been received
    {
        if(g_u8DataLen != 2)
        {
            I2C_SET_DATA(I2C1, g_au8TxData[g_u8DataLen++]);
            I2C_SET_CONTROL_REG(I2C1, I2C_I2CON_SI);
        }
        else
        {
            I2C_SET_CONTROL_REG(I2C1, I2C_I2CON_STA_SI);
        }
    }
    else if(u32Status == 0x10)                  // Repeat START has been transmitted and prepare SLA+R
    {
        I2C_SET_DATA(I2C1, ((g_u8DeviceAddr << 1) | 0x01));   // Write SLA+R to Register I2CDAT 
        I2C_SET_CONTROL_REG(I2C1, I2C_I2CON_SI);
    }
    else if(u32Status == 0x40)                  // SLA+R has been transmitted and ACK has been received
    {
        I2C_SET_CONTROL_REG(I2C1, I2C_I2CON_SI);
    }
    else if(u32Status == 0x58)                  // DATA has been received and NACK has been returned
    {
        g_u8RxData = (unsigned char) I2C_GET_DATA(I2C1);
        I2C_SET_CONTROL_REG(I2C1, I2C_I2CON_STO_SI);
        g_u8EndFlag = 1;
    }
    else
    {
        printf("Status 0x%x is NOT processed\n", u32Status);
    }
}

/*---------------------------------------------------------------------------------------------------------*/
/*  I2C Tx Callback Function                                                                               */
/*---------------------------------------------------------------------------------------------------------*/
void I2C_MasterTx(uint32_t u32Status)
{
    if(u32Status == 0x08)                        // START has been transmitted
    {
        I2C_SET_DATA(I2C1, g_u8DeviceAddr << 1); // Write SLA+W to Register I2CDAT
        I2C_SET_CONTROL_REG(I2C1, I2C_I2CON_SI);
    }
    else if(u32Status == 0x18)                   // SLA+W has been transmitted and ACK has been received
    {
        I2C_SET_DATA(I2C1, g_au8TxData[g_u8DataLen++]);
        I2C_SET_CONTROL_REG(I2C1, I2C_I2CON_SI);
    }
    else if(u32Status == 0x20)                  // SLA+W has been transmitted and NACK has been received
    {
        I2C_STOP(I2C1);
        I2C_START(I2C1);
    }
    else if(u32Status == 0x28)                  // DATA has been transmitted and ACK has been received
    {
        if(g_u8DataLen != 3)
        {
            I2C_SET_DATA(I2C1, g_au8TxData[g_u8DataLen++]);
            I2C_SET_CONTROL_REG(I2C1, I2C_I2CON_SI);
        }
        else
        {
            I2C_SET_CONTROL_REG(I2C1, I2C_I2CON_STO_SI);
            g_u8EndFlag = 1;
        }
    }
    else
    {
        printf("Status 0x%x is NOT processed\n", u32Status);
    }
}

void Close_I2C(void)
{
    I2C_DisableInt(I2C1);       // Disable I2C1 interrupt generation
    NVIC_DisableIRQ(I2C1_IRQn); // Disable NVIC I2C1 interrupt input
    I2C_Close(I2C1);            // Disable I2C1 control module
    CLK_DisableModuleClock(I2C1_MODULE); // Disable I2C module clock
}

void Init_I2C(void)
{
    I2C_Open(I2C1, I2C1_CLOCK_FREQUENCY);
    printf("I2C clock %d Hz\n", I2C_GetBusClockFreq(I2C1)); // get I2C1 clock

    I2C_EnableInt(I2C1);       // Enable I2C1 interrupt generation
    NVIC_EnableIRQ(I2C1_IRQn); // Enable NVIC I2C1 interrupt input
}

void EEPROM_Write(uint16_t addr, uint8_t data)
{
	uint8_t i;
  g_u8DeviceAddr = 0x50; // 24LC64 device address = 0xA0
	g_au8TxData[0] = (uint8_t)((addr & 0xFF00) >> 8);
  g_au8TxData[1] = (uint8_t)(addr & 0x00FF);
	g_au8TxData[2] = data;

  g_u8DataLen = 0;
  g_u8EndFlag = 0;

  s_I2C1HandlerFn = (I2C_FUNC)I2C_MasterTx; // I2C function to write data to slave
  I2C_SET_CONTROL_REG(I2C1, I2C_I2CON_STA); // I2C as master sends START signal 
  while(g_u8EndFlag == 0);                  // Wait I2C Tx Finish 
  g_u8EndFlag = 0;
}

uint8_t EEPROM_Read(uint16_t addr)
{
  s_I2C1HandlerFn = (I2C_FUNC)I2C_MasterRx; // I2C function to read data from slave
  g_u8DataLen = 0;
  g_u8DeviceAddr = 0x50;
	g_au8TxData[0] = (uint8_t)((addr & 0xFF00) >> 8);
  g_au8TxData[1] = (uint8_t)(addr & 0x00FF);
	
  I2C_SET_CONTROL_REG(I2C1, I2C_I2CON_STA);      
  while(g_u8EndFlag == 0);// Wait I2C Rx Finish
  g_u8EndFlag = 0;
	
	return g_u8RxData;
}





uint32_t i;
void check_answer(){
	bool correct=1;
	for(i=0;i<4;i++){
	if(password.value[i]!=guess.value[i])
		correct=0;

	}
	if(correct){
		printS(64,guess.ypos,"PASS");
	}
	else{
	 printS(64,guess.ypos,"ERROR");
	}

}
void EINT1_IRQHandler(void)// IRQ handler of GPIO
{
    GPIO_CLR_INT_FLAG(PB, BIT15);	// Clear GPIO interrupt flag
		test_mode=1;
		PA12=1;PA13=1;PA14=0;
	clear_LCD();
	
}

void Init_EXTINT(void)// init the GPIO Set as interrupt
{
    // Configure EINT1 pin and enable interrupt by rising and falling edge trigger
    GPIO_SetMode(PB, BIT15, GPIO_MODE_INPUT);// as an input
    GPIO_EnableEINT1(PB, 15, GPIO_INT_RISING); // RISING, FALLING, BOTH_EDGE, HIGH, LOW
    NVIC_EnableIRQ(EINT1_IRQn);//NVIC can hear

    // Enable interrupt de-bounce function and select de-bounce sampling cycle time
    GPIO_SET_DEBOUNCE_TIME(GPIO_DBCLKSRC_LIRC, GPIO_DBCLKSEL_64);
    GPIO_ENABLE_DEBOUNCE(PB, BIT15);
}

int32_t main(void)
{
  
	uint8_t data;
Init_EXTINT();
  SYS_Init();//initial
 // printf("EEPRON 24LC64 read/write Test begin...\n");

  Init_I2C();
	 Init_Timer1();
	Init_KEY();
 // OpenSevenSegment();

	init_LCD();
	clear_LCD();
		printS(0,0,"Send");
	password.ypos=16;
	while(password.index!=4) {	
		if(KEY_Flag!=0){
		
			password.value[password.index]=KEY_Flag;
			password.index++;
			printC(password.xpos,password.ypos,KEY_Flag+'0');
			password.xpos+=8;
			
		KEY_Flag=0;
		}
	}
	printS(64,16,"send");
	for (i=0; i<4; i++) EEPROM_Write(i, password.value[i]);

	
	
	

  s_I2C1HandlerFn = NULL;
  Close_I2C(); // close I2C
	//while(test_mode==0){};
	
  while(1){
	if(test_mode){
	if(KEY_Flag!=0){
		
			guess.value[guess.index]=KEY_Flag;
			guess.index++;
			printC(guess.xpos,guess.ypos,KEY_Flag+'0');
			guess.xpos+=8;
			
		KEY_Flag=0;
		}
	if(guess.index==4){
			check_answer();
	    guess.index=0;
		  guess.xpos=0;
			guess.ypos+=16;
	}
	
	
	};
}
}



